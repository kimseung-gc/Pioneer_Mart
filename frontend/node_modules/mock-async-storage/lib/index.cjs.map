{"version":3,"sources":["../src/index.ts","../src/mockAsyncStorage.ts"],"sourcesContent":["import MockAsyncStorage from './mockAsyncStorage'\n\nexport default MockAsyncStorage\n","import merge from \"deepmerge\";\n\nexport type Entry<K, V> = [K, V | null];\n\nexport type Entries<K, V> = Array<Entry<K, V>>;\n\nexport type ErrBack<V> = (err: Error | null, val?: V | null) => void;\n\nexport type ArrErrBack<V> = (err: Array<Error> | null, val?: V) => void;\n\nconst isStringified = (str: string): boolean => {\n  try {\n    JSON.parse(str);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nclass AsyncDict<K, V> {\n  store: Map<K, V | null>;\n\n  size(): number {\n    return this.store.size;\n  }\n\n  getStore(): Map<K, V | null> {\n    return new Map(this.store);\n  }\n\n  constructor() {\n    this.store = new Map();\n  }\n\n  async getItem(k: K, cb?: ErrBack<V>): Promise<V | null> {\n    const val = this.store.get(k) || null;\n    if (cb) cb(null, val);\n    return val;\n  }\n\n  async setItem(k: K, v: V, cb?: ErrBack<V>): Promise<void> {\n    this.store.set(k, v);\n    if (cb) cb(null);\n  }\n\n  async removeItem(k: K, cb?: ErrBack<V>): Promise<void> {\n    this.store.delete(k);\n    if (cb) cb(null);\n  }\n\n  async clear(cb?: ErrBack<V>): Promise<void> {\n    this.store.clear();\n    if (cb) cb(null);\n  }\n\n  async getAllKeys(cb?: ErrBack<Array<K>>): Promise<Array<K>> {\n    const keys: Array<K> = Array.from(this.store.keys());\n    if (cb) cb(null, keys);\n    return keys;\n  }\n\n  async multiGet(\n    keys: Array<K>,\n    cb?: ErrBack<Entries<K, V>>\n  ): Promise<Entries<K, V>> {\n    const requested: Entries<K, V> = keys.map((k) => [\n      k,\n      this.store.get(k) || null,\n    ]);\n    if (cb) cb(null, requested);\n    return requested;\n  }\n\n  async multiSet(entries: Entries<K, V>, cb?: ErrBack<V>): Promise<void> {\n    for (const [key, value] of entries) {\n      this.store.set(key, value);\n    }\n    if (cb) cb(null);\n  }\n\n  async multiRemove(keys: Array<K>, cb?: ErrBack<V>): Promise<void> {\n    for (const key of keys) {\n      this.store.delete(key);\n    }\n    if (cb) cb(null);\n  }\n}\n\nclass MockAsyncStorage extends AsyncDict<string, string> {\n  async mergeItem(\n    key: string,\n    value: string,\n    cb?: ErrBack<string>\n  ): Promise<void> {\n    const item: string | null = await this.getItem(key);\n\n    if (!item) throw new Error(`No item with ${key} key`);\n    if (!isStringified(item)) throw new Error(`Invalid item with ${key} key`);\n    if (!isStringified(value))\n      throw new Error(`Invalid value to merge with ${key}`);\n\n    const itemObj: unknown = JSON.parse(item);\n    const valueObj: unknown = JSON.parse(value);\n    const merged: unknown = merge(itemObj, valueObj);\n\n    await this.setItem(key, JSON.stringify(merged));\n\n    if (cb) cb(null);\n  }\n\n  async multiMerge(\n    entries: Entries<string, string>,\n    cb?: ArrErrBack<string>\n  ): Promise<void> {\n    const errors: Array<Error> = [];\n\n    for (const [key, value] of entries) {\n      try {\n        if (value) {\n          await this.mergeItem(key, value);\n        }\n      } catch (err) {\n        errors.push(err as Error);\n      }\n    }\n\n    if (errors.length) {\n      if (cb) cb(errors);\n      return Promise.reject(errors);\n    }\n\n    if (cb) cb(null);\n    return Promise.resolve();\n  }\n\n  flushGetRequests() {}\n}\n\nexport default MockAsyncStorage;\n"],"mappings":"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","names":["merge"]}