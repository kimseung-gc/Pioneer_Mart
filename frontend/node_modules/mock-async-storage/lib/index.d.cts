type Entry<K, V> = [K, V | null];
type Entries<K, V> = Array<Entry<K, V>>;
type ErrBack<V> = (err: Error | null, val?: V | null) => void;
type ArrErrBack<V> = (err: Array<Error> | null, val?: V) => void;
declare class AsyncDict<K, V> {
    store: Map<K, V | null>;
    size(): number;
    getStore(): Map<K, V | null>;
    constructor();
    getItem(k: K, cb?: ErrBack<V>): Promise<V | null>;
    setItem(k: K, v: V, cb?: ErrBack<V>): Promise<void>;
    removeItem(k: K, cb?: ErrBack<V>): Promise<void>;
    clear(cb?: ErrBack<V>): Promise<void>;
    getAllKeys(cb?: ErrBack<Array<K>>): Promise<Array<K>>;
    multiGet(keys: Array<K>, cb?: ErrBack<Entries<K, V>>): Promise<Entries<K, V>>;
    multiSet(entries: Entries<K, V>, cb?: ErrBack<V>): Promise<void>;
    multiRemove(keys: Array<K>, cb?: ErrBack<V>): Promise<void>;
}
declare class MockAsyncStorage extends AsyncDict<string, string> {
    mergeItem(key: string, value: string, cb?: ErrBack<string>): Promise<void>;
    multiMerge(entries: Entries<string, string>, cb?: ArrErrBack<string>): Promise<void>;
    flushGetRequests(): void;
}

export { MockAsyncStorage as default };
