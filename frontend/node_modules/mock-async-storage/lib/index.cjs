"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/mockAsyncStorage.ts
var import_deepmerge = __toESM(require("deepmerge"), 1);
var isStringified = (str) => {
  try {
    JSON.parse(str);
    return true;
  } catch (e) {
    return false;
  }
};
var AsyncDict = class {
  store;
  size() {
    return this.store.size;
  }
  getStore() {
    return new Map(this.store);
  }
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  async getItem(k, cb) {
    const val = this.store.get(k) || null;
    if (cb)
      cb(null, val);
    return val;
  }
  async setItem(k, v, cb) {
    this.store.set(k, v);
    if (cb)
      cb(null);
  }
  async removeItem(k, cb) {
    this.store.delete(k);
    if (cb)
      cb(null);
  }
  async clear(cb) {
    this.store.clear();
    if (cb)
      cb(null);
  }
  async getAllKeys(cb) {
    const keys = Array.from(this.store.keys());
    if (cb)
      cb(null, keys);
    return keys;
  }
  async multiGet(keys, cb) {
    const requested = keys.map((k) => [
      k,
      this.store.get(k) || null
    ]);
    if (cb)
      cb(null, requested);
    return requested;
  }
  async multiSet(entries, cb) {
    for (const [key, value] of entries) {
      this.store.set(key, value);
    }
    if (cb)
      cb(null);
  }
  async multiRemove(keys, cb) {
    for (const key of keys) {
      this.store.delete(key);
    }
    if (cb)
      cb(null);
  }
};
var MockAsyncStorage = class extends AsyncDict {
  async mergeItem(key, value, cb) {
    const item = await this.getItem(key);
    if (!item)
      throw new Error(`No item with ${key} key`);
    if (!isStringified(item))
      throw new Error(`Invalid item with ${key} key`);
    if (!isStringified(value))
      throw new Error(`Invalid value to merge with ${key}`);
    const itemObj = JSON.parse(item);
    const valueObj = JSON.parse(value);
    const merged = (0, import_deepmerge.default)(itemObj, valueObj);
    await this.setItem(key, JSON.stringify(merged));
    if (cb)
      cb(null);
  }
  async multiMerge(entries, cb) {
    const errors = [];
    for (const [key, value] of entries) {
      try {
        if (value) {
          await this.mergeItem(key, value);
        }
      } catch (err) {
        errors.push(err);
      }
    }
    if (errors.length) {
      if (cb)
        cb(errors);
      return Promise.reject(errors);
    }
    if (cb)
      cb(null);
    return Promise.resolve();
  }
  flushGetRequests() {
  }
};
var mockAsyncStorage_default = MockAsyncStorage;

// src/index.ts
var src_default = mockAsyncStorage_default;
//# sourceMappingURL=index.cjs.map